#!/usr/bin/env ruby
#vim: sw=2 ts=2 sts=2:

require 'json'

require 'cidb'
require 'cidb/ql'

module CIDB
module Builds
  # Command line for creating and updating builds
  class Command
    include CIDB::Sloppy

    description <<~EOTXT
      Builds are the core of CIDB. This command is for creating and updating them.

      To see what builds are in the db, use `cidb-list builds` instead.

      WARNING: Internal: For use by scan and other tools during injest.

      The command acts on the current local build dir, accessed via `cidb-data`
      (basically `$CIDB_DATA/build.yaml`) and it's matching database records.
      These two are tied together via the build_id. For new builds CIDB_BUILD_ID
      is read (scan will have set this). If the build has been imported already
      we read 'build.build_id' data key. Can override with `--build-id`.
    EOTXT

    def slop(o)
      o.boolean '--put',      'Put the build - create if not there, update if it is.'
      o.string  '--build-id', 'The build_id for the new build when creating'
      o.boolean '--count',    'Output total count of builds'
    end

    def main(opts, args)
      return put_build(opts, args) if opts.put?
      return count(opts, args)     if opts.count?

      id = build_id!
      build = get_build(id)
      raise Error, "Build id=#{id.inspect} not found!" unless build
      puts build.to_json
    end

    # Work out the current build_id. fatal! if not found.
    def build_id!
      @opts[:build_id] ||
        Data.fetch('build.build_id', nil) ||
        ENV['CIDB_BUILD_ID'] ||
        fatal!('build_id not set and is not derivable. Set CIDB_BUILD_ID or use --build_id.')
    end

    def count(_opts, _args)
      fatal! "TODO: count of builds"
    end

    private

    def get_build(id)
      gql = <<~GRAPHQL
        query ($id: String) {
          builds(where: {build_id: {_eq: $id}}) {
            build_id
            repository
          }
        }
      GRAPHQL
      CIDB::QL.query(gql, { id: id.to_s }).data.to_h['builds'][0]
    end

    # TODO: Check the Storage, create key if needed, merge that json?
    def put_build(opts, _args)
      id = build_id!
      data = {
        builder:     Data.fetch('build.builder', 'unknown'),
        builder_url: Data.fetch('build.builder_url', ''),
        repository:  Data.fetch('build.repository', ''),
        revision:    Data.fetch('build.revision', ''),
        branch:      Data.fetch('build.branch', ''),
      }
      put_build_data id, data
    end

    def put_build_data(id, data)
      build = get_build id
      if build
        data = build.merge data
        CIDB::QL.query do
          mutation do
            update_builds_by_pk(pk_columns: { build_id: id }, _set: build)
          end
        end
        info "Updated build: #{id}"
      else
        build = { build_id: id }.merge data
        CIDB::QL.query do
          mutation do
            insert_builds(objects: [build]) do
              affected_rows
            end
          end
        end
        info "Added build: #{id}"
      end
    end
  end
end #Builds
end #CIDB

CIDB::Builds::Command.new.run
