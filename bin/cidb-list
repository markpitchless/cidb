#!/usr/bin/env ruby
#vim: sw=2 ts=2 sts=2:

require 'csv'
require 'terminal-table'
require 'cidb'
require 'cidb/ql'

module CIDB
  class ListCommand
    include CIDB::Sloppy

    banner "%{prog} [OPTIONS] [LIST_PATH]"

    description <<~EOTXT
    List things in cidb. With no arguments, prints a list of paths you can list:

      cidb list

    Run with a path and options to list stuff from the db. Note default limit is
    10 (to stop flodding your terminal) and can be controlled via the --limit
    and --offset options.

      cidb list builds
      cidb list test_suites --limit 200
      cidb list test_cases --offset=40
    EOTXT

    def slop(o)
      o.integer "--limit", "Max number of records to show", default: 10
      o.integer "--offset", "Record position to start listing from", default: 0
      o.string "--build-id", "Filter by the given build id"
      o.boolean "--json"
      o.boolean "--csv"
    end

    def main(opts, args)
      return list_data_sets if args.empty?
      list(opts, args)
    end

    def list_data_sets
      # TODO: re-impliment counts for these
      puts 'builds'
      puts 'test_suites'
      puts 'test_cases'
    end

    def list(opts, args)
      name = args[0]

      data = case name.to_sym
      when :builds               then list_builds
      when :test_suites, :suites then list_test_suites
      when :test_cases, :cases   then list_test_cases
      else
        fatal! "List #{name.inspect} not found"
      end

      # TODO: re-add build_id, limit and offset
      # ds = DB[name.to_sym]
      # ds = ds.where(build_id: opts[:build_id]) if opts.build_id?
      # ds = ds.limit(opts[:limit]).offset(opts[:offset])

      return puts data.to_json if opts.json?
      return csv(data)         if opts.csv?
      return table('foo', data)
    end

    def list_builds
      res = CIDB::QL.query <<~GRAPHQL
        query {
          builds {
            build_id
            repository
            revision
            branch
            builder
            builder_url
          }
        }
      GRAPHQL
      res.data.to_h['builds']
    end

    def list_test_suites
      res = CIDB::QL.query <<~GRAPHQL
        query {
          test_suites {
            build_id
            errors
            failures
            name
            tests
            time
            timestamp
          }
        }
      GRAPHQL
      res.data.to_h['test_suites']
    end

    def list_test_cases
      res = CIDB::QL.query <<~GRAPHQL
        query {
          test_cases {
            build_id
            classname
            failed
            name
            skipped
            suite_name
            time
          }
        }
      GRAPHQL
      res.data.to_h['test_cases']
    end

    def csv(data)
      names = data[0].keys
      puts CSV.generate_line(names)
      data.each do |r|
        puts CSV.generate_line(r.values_at(*names))
      end
    end

    def table(name, data) # Terminal table for humans
      names = data[0].keys
      total = data.size
      table = Terminal::Table.new do |t|
        t.headings = [:'#'] + names
        t.style = { border: :unicode, border_top: false, border_bottom: false, border_left: false, border_right: false }
        data.each_with_index { |row, i| t << [i+1] + row.values }
        t.align_column 0, :right
      end
      puts table
      # TODO: re-add this with limits and offset. Needs a total.
      # puts "#{@opts[:offset]+1} to #{data.size + @opts[:offset]} of #{total} #{name}"
    end
  end
end #CIDB

CIDB::ListCommand.new.run
